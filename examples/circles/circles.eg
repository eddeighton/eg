
include( "glm/vec2.hpp" );

cinder::app::getWindow()->setTitle( "Awesome" );
cinder::app::getWindow()->setSize( 1024, 1024 );
cinder::app::setWindowPos( 100, 100 );

dim float morphSpeed;

abstract Shape
{
    dim glm::vec2 position;
    dim glm::vec2 positionOffset;
    dim glm::vec2 positionActual;
    dim cinder::Color color;
    dim float size;
    dim float sizeActual;
    
    action Default( float fColour )
    {
        color( cinder::Color( cinder::CM_HSV, fColour, 1, 1 ) );
        position( cinder::app::getWindowCenter() );
        size( 25.0f );
        sizeActual( size() );
    }
    
    dim float f;

    action ColorChanger
    {
        while( true )
        {
            f( fmodf( f() + clock::dt() * 0.3, 1.0f ) );
            color( cinder::Color( cinder::CM_HSV, f(), 1, 1 ) );
            eg::sleep();
        }
    }
    
    action SizeChanger : Waves
    {
        dim float amt;
        dim float offset;
        
        Triangle.Start();
        
        while( true )
        {
            offset( f() );
            sizeActual( size() + Triangle.value() * amt() );
            eg::sleep();
        }
        
    }
    
    action Perturbe
    {
        dim int rate;
        dim int range;
        
        while( true )
        {
            if( rate() > 0 )
            {
                eg::sleep( std::chrono::milliseconds( rate() ) );
                if( range() > 0 )
                {
                    const float iRandx = ( rand() % range() ) - ( range() / 2.0f );
                    const float iRandy = ( rand() % range() ) - ( range() / 2.0f );
                    positionOffset( position() + glm::vec2( iRandx, iRandy ) );
                }
                else
                {
                    positionOffset( position() );
                }
            }
            else
            {
                positionOffset( position() );
                eg::sleep();
            }
        }
    }
    
    action Morph
    {
        while( true )
        {
            positionActual( positionActual() + 
                ( positionOffset() - positionActual() ) * clock::dt() * morphSpeed() );
            eg::sleep();        
        }
    }
}

action StrokedCircle[ 4096 ] : Shape
{
    while( true )
    {
        cinder::gl::color( color() );
        cinder::gl::drawStrokedCircle( positionActual(), sizeActual() );
        eg::sleep();
    }
}

action Circle[ 4096 ] : Shape
{
    while( true )
    {
        cinder::gl::color( color() ); 
        cinder::gl::drawSolidCircle( positionActual(), sizeActual() );
        eg::sleep();
    }
}

action Spiral
{
    dim float curve;
    dim float radius;
    dim float relative;
    dim float speed;
    
    while( true )
    {
        const int numCircles = eg::count( root.Get().Shape.Range() );
        
        int index = 0;
        const glm::vec2 center = cinder::app::getWindowCenter();
        for( Shape circle : root.Get().Shape.Range() )
        {
            float rel = ( clock::ct() * speed() / 10 ) + ( index * relative() / (float)numCircles );
            float angle = rel * M_PI * 10;
            glm::vec2 offset( cos( angle ), sin( angle ) );
        
            circle.position( center + ( offset * radius() ) + ( offset * ( curve() * index ) ) );
            circle.f( ( index / (float)numCircles ) );
        
            ++index;
        }
        eg::sleep();
    }
}

action Grid
{
    dim float spacing;
    
    const int numCircles = eg::count( root.Get().Shape.Range() );
    if( numCircles > 0 )
    {
        int side = sqrt( ( float )numCircles );
        
        int iCounter = 0;
        for( Shape shape : root.Get().Shape.Range() )
        {
            int x = iCounter / side;
            int y = iCounter % side;
            
            shape.position( glm::vec2( x * spacing(), y * spacing() ) );
            shape.f( iCounter / (float)numCircles );
            
            ++iCounter;
        }
    }
}

action Attract
{
    const int numCircles = eg::count( root.Get().Shape.Range() );
    if( numCircles > 0 )
    {
        bool bFirst = true;
        glm::vec2 center;
        for( Shape circle : root.Get().Shape.Range() )
        {
            if( bFirst )
            {
                center = circle.positionActual();
                bFirst = false;
            }
            else
                circle.positionActual( center );
        }
    }
}

action Randomise
{
    const glm::vec2 center = cinder::app::getWindowCenter();
    dim int range;
    if( range() > 0 )
    {
        for( Shape s : root.Get().Shape.Range() )
        {
            float iRand1 = rand() % range();
            float iRand2 = rand() % range();
            
            float fRandAngle = iRand1 * ( M_PI * 2.0f ) / (float)range();
            
            glm::vec2 vRand = glm::vec2( cos( fRandAngle ), sin( fRandAngle ) ) * iRand2;
        
            s.positionActual( center + vRand );
        }
    }
}

action setPerturbe
{
    dim float iRate;
    dim float iRange;
    
    for( Shape::Perturbe p : root.Get().Shape.Perturbe.Raw() )
    {
        p.rate( iRate() * 1000.0f );
        p.range( iRange() );
    }
}

action setSize
{
    dim float iAmount;
    dim float iRate;
    dim float iSize;
    
    for( Shape s : root.Get().Shape.Raw() )
    {
        s.size( iSize() );
        s.SizeChanger.Triangle.rate( iRate() );
        s.SizeChanger.amt( iAmount() );
    }
}

action imgui
{
    while( true )
    {
        ImGui::Begin( "Tweakatron 9000" );
        ImGui::SliderInt( "Random Range", &Randomise.range.Get(), 1, 10000 );
        ImGui::SliderFloat( "rotation speed", &Spiral.speed.Get(), 0.0f, 2.0f );
        
        
        if( ImGui::SliderFloat( "curve", &Spiral.curve.Get(), 0.0f, 4.0f ) )
        {
            Spiral.Start();
            Spiral.Stop();
        }
        
        if( ImGui::SliderFloat( "radius", &Spiral.radius.Get(), -100.0f, 100.0f ) )
        {
            Spiral.Start();
            Spiral.Stop();
        }
        
        if( ImGui::SliderFloat( "angle", &Spiral.relative.Get(), -10.0f, 10.0f ) )
        {
            Spiral.Start();
            Spiral.Stop();
        }
        
        ImGui::SliderFloat( "morph speed", &morphSpeed.Get(), 0.0f, 32.0f );
        
        if( ImGui::SliderFloat( "perturbe rate", &setPerturbe.iRate.Get(), 0.0f, 5.0f ) )
        {
            setPerturbe();
        }
        if( ImGui::SliderFloat( "perturbe range", &setPerturbe.iRange.Get(), 0.0f, 1000.0f ) )
        {
            setPerturbe();
        }
        
        if( ImGui::SliderFloat( "size", &setSize.iSize.Get(), 0.0f, 200.0f ) )
        {
            setSize();
        }
        if( ImGui::SliderFloat( "size amt", &setSize.iAmount.Get(), 0.0f, 100.0f ) )
        {
            setSize();
        }
        if( ImGui::SliderFloat( "size rate", &setSize.iRate.Get(), 0.0f, 1.0f ) )
        {
            setSize();
        }
        
        ImGui::SliderFloat( "grid spacing", &Grid.spacing.Get(), 0.0f, 1000.0f );
    
        if( ImGui::Button( "Spiral" ) )
        {
            if( eg::count( root.Get().Spiral.Range() ) )
                Spiral.Stop();
            else
                Spiral.Start();
        }
        else if( ImGui::Button( "Burst" ) )
        {
            Spiral.Start();
            Spiral.Stop();
        }
        else if( ImGui::Button( "Rand" ) )
        {
            Randomise();
        }
        else if( ImGui::Button( "Attract" ) )
        {
            Attract();
        }
        /*else if( ImGui::Button( "Update Perturbe" ) )
        {
            setPerturbe();
        }*/
        else if( ImGui::Button( "Grid" ) )
        {
            Grid();
        }
        else if( ImGui::Button( "Quit" ) )
        {
            root.Stop();
        }
        ImGui::End();
        eg::sleep();
    }
}
imgui.Start();

while( true )
{
	cinder::gl::clear();
    eg::sleep();
}
