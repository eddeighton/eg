
include( "py_glm.hpp" );

abstract Shape
{
    dim vec2 position;
    dim vec2 positionActual;
    dim Color color;
    dim float size;
    
    action Default
    {
        color( Color( CM_HSV, 0.5f, 1, 1 ) );
        position( getWindowCenter() );
        size( 25.0f );
    }
    
    action ColorChanger
    {
        dim float f;
        while( true )
        {
            f( fmodf( f() + clock::dt() * 0.3, 1.0f ) );
            color( Color( CM_HSV, f(), 1, 1 ) );
            eg::sleep();
        }
    }
    
    action Morph
    {
        dim float speed;
        
        while( true )
        {
            positionActual( positionActual() + 
                ( position() - positionActual() ) * clock::dt() * speed() );
            eg::sleep();        
        }
    }
}


action StrokedCircle[ 256 ] : Shape
{
    while( true )
    {
        gl::color( color() );
        gl::drawStrokedCircle( positionActual(), size() );
        eg::sleep();
    }
}

action Circle[ 256 ] : Shape
{
    while( true )
    {
        gl::color( color() ); 
        gl::drawSolidCircle( positionActual(), size() );
        eg::sleep();
    }
}

action Spiral
{
    dim float speed;
    dim float curve;
    
    while( true )
    {
        const int numCircles = eg::count( root.Get().Shape.Range() );
        
        int index = 0;
        const vec2 center = getWindowCenter();
        float radius = 1.0f;
        for( Shape circle : root.Get().Shape.Range() )
        {
            float rel = ( clock::ct() / 10 ) + ( index / (float)numCircles );
            float angle = rel * M_PI * 10;
            vec2 offset( cos( angle ), sin( angle ) );
        
            circle.position( center + offset * radius * speed() );
            circle.f( ( index / (float)numCircles ) );
            
            radius = radius + curve();
        
            ++index;
        }
        eg::sleep();
    }

}

action Randomise
{
    const vec2 center = getWindowCenter();
    dim int range;
    range( 400 );
    for( Shape s : root.Get().Shape.Range() )
    {
        vec2 vRand( center.x * float( ( rand() % range() ) - ( range() / 2 ) ),
            center.y * float( ( rand() % range() ) - ( range() / 2 ) ) );
        s.position( vRand );
    }
}

bool bContinue = true;
while( bContinue )
{
    while( std::optional< InputEvent > eOpt = Input::getEvent() )
    {
        const InputEvent& e = eOpt.value();
        switch( e.type )
        {
            case InputEvent::eKeyDown:
                if( e.keyEvent.getChar() == 's')
                {
                    bContinue = false;
                }
                else if(  e.keyEvent.getChar() == 'r' )
                {
                    Randomise();
                }
                break;
            default:
                break;
        }
    }
	gl::clear();
    eg::sleep();
}
