
include( "py_glm.hpp" );

abstract Shape
{
    dim vec2 position;
    dim Color color;
    dim float size;
    
    action Default
    {
        color( Color( CM_HSV, 0.5f, 1, 1 ) );
        position( getWindowCenter() );
        size( 25.0f );
    }
    
    action ColorChanger
    {
        dim float f;
        while( true )
        {
            f( fmodf( f() + clock::dt() * 0.3, 1.0f ) );
            color( Color( CM_HSV, f(), 1, 1 ) );
            eg::sleep();
        }
    }
    
    action Move
    {
        dim vec2 target;
        dim float speed;
        
        vec2 diff = target() - position();
        while( length( diff ) > 1.0f )
        {
            position( position() + diff * speed() * clock::dt() );
            eg::sleep();
            diff = target() - position();
        }
    }
}


action StrokedCircle[ 2048 ] : Shape
{
    while( true )
    {
        gl::color( color() ); // red
        gl::drawStrokedCircle( position(), size() );
        eg::sleep();
    }
}

action Circle[ 2048 ] : Shape
{
    while( true )
    {
        gl::color( color() ); 
        gl::drawSolidCircle( position(), size() );
        eg::sleep();
    }
}

action Spiral
{
    dim float speed;
    dim float curve;
    
    while( true )
    {
        root r = root.Get();
        const int numCircles = eg::count( r.Circle.Range() );
        
        int index = 0;
        const vec2 center = getWindowCenter();
        float radius = 1.0f;
        for( Circle circle : r.Circle.Range() )
        {
            float rel = ( clock::ct() / 10 ) + ( index / (float)numCircles );
            float angle = rel * M_PI * 10;
            vec2 offset( cos( angle ), sin( angle ) );
        
            circle.position( center + offset * radius * speed() );
            circle.size( 25.0f );
            
            radius = radius + curve();
        
            ++index;
        }
        eg::sleep();
    }

}

bool bContinue = true;
while( bContinue )
{
    while( std::optional< InputEvent > eOpt = Input::getEvent() )
    {
        const InputEvent& e = eOpt.value();
        switch( e.type )
        {
            case InputEvent::eKeyDown:
                if( e.keyEvent.getChar() == 's')
                {
                    bContinue = false;
                }
                break;
            default:
                break;
        }
    }
	gl::clear();
    eg::sleep();
}
