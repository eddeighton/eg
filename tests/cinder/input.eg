

action Circle[ 4096 ]
{
    dim vec2 position;
    dim Color color;
    
    const float max_size = 10.0f;
    const float max_lifetime = 4.0f;
    
    float size = max_size;
    
    const float startTime = clock::ct();
    float lifetime = startTime + max_lifetime;
    while( clock::ct() < lifetime )
    {
        size = ( lifetime - clock::ct() ) * max_size;
        
        gl::color( color() ); // red
        gl::drawSolidCircle( position(), size );
        SLEEP;
    }
    
    action Move
    {
        dim vec2 direction;
        while( true )
        {
            position( position() + direction() * clock::dt() );
            SLEEP;
        }
    }
}

action EventListener
{
    while( true )
    {
        while( EGEvent e = get_next_event() )
        {
            if( Circle c = e )
            {
                LOG( "Circle died at pos: " << c.position() << " and time: " << clock::ct() );
            }
        }
        SLEEP;
    }
}

EventListener.Start();

bool bContinue = true;
while( bContinue )
{
	gl::clear();
    
    dim std::optional< vec2 > lastPos;
    
    while( std::optional< InputEvent > eventOpt = Input::getEvent() )
    {
        const InputEvent& e = eventOpt.value();
        switch( e.type )
        {
            case InputEvent::eMouseDown:
                {
                    lastPos( std::optional< vec2 >( e.mouseEvent.getPos() ) );
                    if( Circle c = Circle.Start() )
                    {
                        c.position( lastPos().value() );
                        c.color( Color( CM_HSV, fmod( clock::ct(), 1.0f ), 1, 1 ) );
                    }
                }
                break;
            case InputEvent::eMouseUp:
                {
                    lastPos( std::optional< vec2 >() );
                }
                break;
            case InputEvent::eMouseMove:
                break;
            case InputEvent::eMouseDrag:
                if( lastPos() )
                {
                    const vec2 mousePos( e.mouseEvent.getPos() );
                    
                    const vec2 dir = mousePos - lastPos().value();
                    const float fSteps = glm::length( dir ) * 0.1f;
                    for( float i = 0.0f; i < fSteps; ++i )
                    {
                        if( Circle c = Circle.Start() )
                        {
                            c.position( lastPos().value() + ( dir * ( i / fSteps ) ) );
                            c.color( Color( CM_HSV, fmod( clock::ct(), 1.0f ), 1, 1 ) );
                        }
                    }
                    lastPos( std::optional< vec2 >( mousePos ) );
                    
                    //try to start a circle
                    if( Circle c = Circle.Start() )
                    {
                        c.position( lastPos().value() );
                        c.color( Color( CM_HSV, fmod( clock::ct(), 1.0f ), 1, 1 ) );
                    }
                }
                else
                {
                    LOG( "Mouse Drag: no lastpos"  );
                }
                break;
            case InputEvent::eMouseWheel:
                break;
            case InputEvent::eKeyDown:
            case InputEvent::eKeyUp:
                if( e.keyEvent.getChar() == ' ' )
                {
                    bContinue = false;
                }
                break;
        }
    }
    
    SLEEP;
}