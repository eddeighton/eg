

action Camera
{
    dim cinder::CameraPersp perspective;
    dim cinder::vec3 eye;
    dim cinder::vec3 offset;
    
    eye( cinder::vec3( 8, 8, 2 ) );
    
    action Orbit : Mouse::Handler
    {
        dim float orbit_rate;
        dim float orbit_radius;
        dim float orbit_magic;
        
        while( true )
        {
            float fAngle = clock::ct() * orbit_rate() * M_PI * 2.0f;
            cinder::vec2 v( sin( fAngle ), cos( fAngle ) );
            eye( cinder::vec3( v.x, v.y, orbit_magic() ) * orbit_radius() );
            eg::sleep();
        }
        
        action Capture : Mouse::Handler::Capture
        {
            action Move : Mouse::Handler::Capture::Move
            {
                const cinder::vec2 dir = current() - Orbit.Capture.down();
                orbit_radius( dir.x );
            }
            
            action Release : Mouse::Handler::Capture::Release
            {
            }
            
            while( true )
                eg::sleep();
        }
    }
    
    action CameraMouse : Mouse::Handler
    {
        dim float radius;
        dim cinder::vec2 rate;
        dim float angle;
        
        action Capture : Mouse::Handler::Capture
        {
            dim cinder::vec3 initialEye;
            initialEye( eye() );
            
            action Move : Mouse::Handler::Capture::Move
            {
                const cinder::vec2 dir = current() - CameraMouse.Capture.down();
                float fNewAngle = angle() - dir.x * rate().x;
                eye( cinder::vec3( sin( fNewAngle ) * radius(), initialEye().y + dir.y * rate().y, cos( fNewAngle ) * radius() ) );
            }
            
            action Release : Mouse::Handler::Capture::Release
            {
                const cinder::vec2 dir = result() - CameraMouse.Capture.down();
                angle( angle() - dir.x * rate().x );
                eye( cinder::vec3( sin( angle() ) * radius(), initialEye().y + dir.y * rate().y, cos( angle() ) * radius() ) );
            }
            
            while( true )
                eg::sleep();
        }
    }
    
    while( true )
    {
        const cinder::vec2 wndSize = cinder::app::getWindow()->getSize();
        perspective.Get().setAspectRatio( static_cast< float >( wndSize.x ) / static_cast< float >( wndSize.y ) );
        perspective.Get().lookAt( offset() + eye(), cinder::vec3( 0 ) );
        eg::sleep();
    }
}


